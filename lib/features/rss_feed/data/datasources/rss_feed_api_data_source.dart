// lib/features/rss_feed/data/datasources/rss_feed_api_data_source.dart

import 'dart:io';
import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:dio/io.dart';
import 'package:lucide_icons/lucide_icons.dart';
import 'package:flutter/foundation.dart';
import 'package:crypto/crypto.dart';
import '../../../../core/services/secure_storage_service.dart';

// FeedItem ve Category modellerini i√ßerir.
// (Kullanƒ±cƒ±nƒ±n model dosyasƒ±na g√∂re Category yerine RssCategory de olabilir.)
import '../../domain/models/feed_item.dart';

final Dio _httpClient = Dio();

// =================================================================
// YARDIMCI FONKSƒ∞YONLAR
// =================================================================

void _setupHttpClientForDev() {
  if (kDebugMode && (Platform.isAndroid || Platform.isIOS)) {
    _httpClient.httpClientAdapter = IOHttpClientAdapter(
      createHttpClient: () {
        final client = HttpClient();
        // Geli≈ütirme ortamƒ±nda SSL sertifika hatalarƒ±nƒ± yok say
        client.badCertificateCallback = (cert, host, port) => true;
        return client;
      },
    );
    if (kDebugMode) print('‚úÖ DEV Ortamƒ±: SSL sertifika doƒürulamasƒ± ATLANDI.');
  }
}

String _formatTimeAgo(int timestamp) {
  final now = DateTime.now();
  final publishedDate = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
  final difference = now.difference(publishedDate);

  if (difference.inDays > 7) {
    return '${publishedDate.day}.${publishedDate.month}.${publishedDate.year}';
  } else if (difference.inDays > 0) {
    return '${difference.inDays} g√ºn √∂nce';
  } else if (difference.inHours > 0) {
    return '${difference.inHours} saat √∂nce';
  } else if (difference.inMinutes > 0) {
    return '${difference.inMinutes} dk √∂nce';
  } else {
    return '≈ûimdi';
  }
}

// =================================================================
// ABSTRACT SINIF TANIMI
// =================================================================
abstract class RssFeedDataSource {
  Future<String> authenticate(String url, String username, String password);
  Future<List<RssCategory>> getCategories(
      String apiUrl, String token); // <<< Tƒ∞P D√úZELTƒ∞LDƒ∞
  Future<List<FeedItem>> getFeedItems(String apiUrl, String token);
  Future<void> markItemStatus(
      String apiUrl, String token, String itemId, bool isRead);
  Future<void> markAllAsRead(String apiUrl, String token);
}

// =================================================================
// SOMUT SINIF UYGULAMASI (Google Reader API Uyumlu)
// =================================================================
class RssFeedApiDataSource implements RssFeedDataSource {
  final Dio _httpClient; // <<< Final olarak tanƒ±mlayƒ±n
  final SecureStorageService _storageService; // <<< Bunu ekleyin
  // Veri Cache'leri
  List<RssCategory> _categoriesCache = [];
  Map<int, int> _feedIdToGroupId = {}; // Feed ID -> Category ID e≈üle≈ütirme
  Map<int, String> _feedIdToFeedName =
      {}; // Feed ID -> Feed Adƒ± (Source Name) e≈üle≈ütirme

  RssFeedApiDataSource(
      {required SecureStorageService
          storageService}) // <<< Constructor'ƒ± g√ºncelleyin
      : _httpClient = Dio(), // Burada ba≈ülatƒ±n
        _storageService = storageService // Enjekte edilen servisi atayƒ±n
  {
    _setupHttpClientForDev();
    _setupDioInterceptors();
  }

  String _normalizeUrl(String url) {
    String normalizedUrl = url.replaceAll(RegExp(r'/+$'), '');
    if (!normalizedUrl.startsWith('https://') &&
        !normalizedUrl.startsWith('http://')) {
      normalizedUrl = 'https://' + normalizedUrl;
    }
    normalizedUrl = normalizedUrl.replaceFirst('http://', 'https://');
    return normalizedUrl;
  }

  // ===============================================================
  // üîê 1. Kimlik Doƒürulama (GRAPI: ClientLogin)
  // ===============================================================
  @override
  Future<String> authenticate(
      String url, String username, String password) async {
    final normalizedUrl = _normalizeUrl(url);
    // D√∂k√ºmantasyonda belirtilen ClientLogin u√ß noktasƒ±
    final authEndpointUrl =
        '$normalizedUrl/p/api/greader.php/accounts/ClientLogin';

    try {
      final response = await _httpClient.post(
        authEndpointUrl,
        data: {
          'Email': username,
          'Passwd': password,
          'accountType': 'HOSTED_OR_GOOGLE',
          'service': 'reader',
        },
        options: Options(
          contentType: Headers.formUrlEncodedContentType,
          // 401 hatalarƒ±nƒ± yakalamak i√ßin validateStatus ayarƒ±
          validateStatus: (status) =>
              status != null &&
              (status >= 200 && status < 400 || status == 401),
        ),
      );

      if (response.statusCode == 200 && response.data is String) {
        final String responseBody = response.data.toString();

        final tokenMatch = RegExp(r'Auth=(.+)\n?').firstMatch(responseBody);
        if (tokenMatch != null && tokenMatch.group(1) != null) {
          // Token: "alice/8e6845e0..." formatƒ±nda d√∂nd√ºr√ºl√ºr
          return tokenMatch.group(1)!;
        } else {
          throw Exception('‚ùå GRAPI yanƒ±tƒ±nda Auth token bulunamadƒ±.');
        }
      } else if (response.statusCode == 401) {
        throw Exception(
            '‚ùå Yetkilendirme Ba≈üarƒ±sƒ±z! Kullanƒ±cƒ± adƒ± veya ≈üifre hatalƒ±.');
      } else {
        throw Exception(
            '‚ùå Kimlik doƒürulama ge√ßersiz yanƒ±t: ${response.statusCode} - ${response.data}');
      }
    } on DioException {
      rethrow;
    } catch (e) {
      throw Exception('‚ö†Ô∏è Beklenmeyen hata (Kimlik Doƒürulama): $e');
    }
  }

  // ===============================================================
  // üìÇ 2. Kategorileri Getir (GRAPI: tag/list + subscription/list)
  // ===============================================================
  @override
  Future<List<RssCategory>> getCategories(String apiUrl, String token) async {
    final normalizedUrl = _normalizeUrl(apiUrl);
    // D√∂k√ºmantasyonda belirtilen u√ß noktalar
    final tagsEndpointUrl =
        '$normalizedUrl/p/api/greader.php/reader/api/0/tag/list?output=json';
    final subscriptionsEndpointUrl =
        '$normalizedUrl/p/api/greader.php/reader/api/0/subscription/list?output=json';

    try {
      // √áALI≈ûAN GRAPI HEADER FORMATI: Authorization: GoogleLogin auth=TOKEN
      final headers = {'Authorization': 'GoogleLogin auth=$token'};

      final tagsResponse = await _httpClient.get(tagsEndpointUrl,
          options: Options(headers: headers));
      final subscriptionsResponse = await _httpClient
          .get(subscriptionsEndpointUrl, options: Options(headers: headers));

      if (tagsResponse.statusCode == 200 &&
          subscriptionsResponse.statusCode == 200) {
        final tagsJson = tagsResponse.data['tags'] as List? ?? [];
        final subscriptionsJson =
            subscriptionsResponse.data['subscriptions'] as List? ?? [];

        // √ñnbellekleri temizle
        _feedIdToFeedName.clear();
        _feedIdToGroupId.clear();

        // --- 2a: Feed/Grup E≈üle≈ütirmesi ve Feed Adƒ± Cache'i ---
        for (var sub in subscriptionsJson) {
          final String feedIdStr = sub['id'] as String? ?? '';
          final String feedTitle =
              sub['title'] as String? ?? 'Bilinmeyen Kaynak';
          final int feedId = feedIdStr
              .hashCode; // FreshRSS'in ID'si URI olduƒüundan hash kullanƒ±lƒ±r

          _feedIdToFeedName[feedId] = feedTitle; // Feed Adƒ±nƒ± Kaydet

          final List categoriesOfFeed = sub['categories'] as List? ?? [];
          for (var categoryEntry in categoriesOfFeed) {
            final String tagId = categoryEntry['id'] as String? ?? '';
            final String categoryName = tagId.split('/').lastWhere(
                (element) => element.isNotEmpty,
                orElse: () => 'Genel');
            final int categoryId = categoryName.hashCode;
            _feedIdToGroupId[feedId] = categoryId;
          }
        }

        // --- 2b: Grup Adlarƒ±, Sayƒ±larƒ± ve Listesi ---
        Map<int, List<int>> groupFeeds = {};
        Map<int, int> groupFeedCount = {};
        Map<int, String> groupIdToName = {};

        // Tags'lardan kategori adlarƒ±nƒ± ve ID'lerini al
        for (var tag in tagsJson) {
          final String tagId = tag['id'] as String? ?? '';
          final String tagName = tagId.split('/').lastWhere(
              (element) => element.isNotEmpty,
              orElse: () => 'Genel');
          final int categoryId = tagName.hashCode;

          groupIdToName[categoryId] = tagName;
          groupFeeds[categoryId] = [];
          groupFeedCount[categoryId] = 0;
        }

        // Genel (Untagged) feed'leri i≈üle
        _feedIdToFeedName.keys.forEach((feedId) {
          final int groupId = _feedIdToGroupId[feedId] ?? 'Genel'.hashCode;
          if (!groupIdToName.containsKey(groupId)) {
            groupIdToName[groupId] = 'Genel';
            groupFeeds[groupId] = [];
            groupFeedCount[groupId] = 0;
            _feedIdToGroupId[feedId] = groupId;
          }
          groupFeeds[groupId]!.add(feedId);
          groupFeedCount[groupId] = (groupFeedCount[groupId] ?? 0) + 1;
        });

        // --- 2c: Category Listesi Olu≈üturma ---
        _categoriesCache = groupIdToName.entries.map((entry) {
          final int groupId = entry.key;
          final String groupName = entry.value;
          final int feedCount = groupFeedCount[groupId] ?? 0;

          return RssCategory(
            id: groupId,
            name: groupName,
            count: feedCount,
            icon: LucideIcons.folder,
            feedIds: groupFeeds[groupId] ?? [],
          );
        }).toList();

        // "Hepsi" Kategorisini Ekle
        List<int> allFeedIds = _feedIdToFeedName.keys.toList();
        int totalFeedCount = allFeedIds.length;
        _categoriesCache.insert(
          0,
          RssCategory(
            name: "Hepsi",
            count: totalFeedCount,
            icon: LucideIcons.home,
            id: 0,
            feedIds: allFeedIds,
          ),
        );

        return _categoriesCache;
      } else {
        throw Exception(
            '‚ùå Kategoriler alƒ±namadƒ±: GRAPI sunucu durumu kodu: Tags: ${tagsResponse.statusCode}, Subscriptions: ${subscriptionsResponse.statusCode}');
      }
    } on DioException catch (e) {
      if (e.type == DioExceptionType.connectionError) {
        throw Exception(
            '‚ö†Ô∏è Baƒülantƒ± Hatasƒ±: Sunucuya eri≈üilemiyor. ${e.message}');
      }
      // Hata Y√∂netimi: Bu blok, 501/Y√∂nlendirme d√∂ng√ºs√º hatalarƒ±nƒ± yakalar
      throw Exception('‚ö†Ô∏è Dio Hatasƒ± olu≈ütu (Kategoriler): ${e.message}');
    } catch (e) {
      throw Exception('‚ö†Ô∏è Beklenmeyen hata (Kategoriler): $e');
    }
  }

  // ===============================================================
  // üì∞ 3. RSS Feed √ñgelerini Getir (GRAPI: stream/contents)
  // ===============================================================
  @override
  Future<List<FeedItem>> getFeedItems(String apiUrl, String token) async {
    final normalizedUrl = _normalizeUrl(apiUrl);
    final streamEndpointUrl =
        '$normalizedUrl/p/api/greader.php/reader/api/0/stream/contents/user/-/state/com.google/reading-list?output=json';

    try {
      final response = await _httpClient.get(
        streamEndpointUrl,
        queryParameters: {'n': 'max', 'r': 'd'},
        options: Options(
          headers: {'Authorization': 'GoogleLogin auth=$token'},
          validateStatus: (status) => status != null && status < 500,
        ),
      );

      if (response.statusCode == 200 && response.data is Map<String, dynamic>) {
        final json = response.data as Map<String, dynamic>;
        final itemsJson = json['items'] as List? ?? [];
        List<FeedItem> feedItems = [];

        // Bu kƒ±sƒ±m, API'den gelen veriyi modelimize d√∂n√º≈üt√ºr√ºr.
        for (var item in itemsJson) {
          final int feedId =
              int.tryParse(item['feed_id']?.toString() ?? '0') ?? 0;
          final String title = item['title'] as String? ?? 'Ba≈ülƒ±ksƒ±z';
          final int timestamp = (item['published'] as int? ?? 0);
          final String itemUrl = item['alternate'] != null &&
                  (item['alternate'] as List).isNotEmpty
              ? (item['alternate'] as List).first['href'] as String? ?? '#'
              : '#';
          final String finalItemIdStr = item['id'] as String? ??
              item['id'].toString(); // ID'yi string olarak al
          final List categories = item['categories'] as List? ?? [];
          final bool isRead =
              categories.contains('user/-/state/com.google/read');

          // Kaynak ve Kategori Adƒ±nƒ± Cache'den √áekme
          final String sourceName = _feedIdToFeedName[feedId] ??
              item['origin']?['title'] as String? ??
              'Bilinmeyen Kaynak';
          final int groupId = _feedIdToGroupId[feedId] ?? 0;
          final String categoryName = _categoriesCache
                  .firstWhereOrNull((cat) => cat.id == groupId)
                  ?.name ??
              'Genel';

          feedItems.add(
            FeedItem(
              id: finalItemIdStr,
              title: title,

              // ‚ùå HATA BURADAYDI: Constructor 'source' bekliyor.
              // sourceName: sourceName, // Yanlƒ±≈ü etiket

              // ‚úÖ D√úZELTME: sourceName deƒüi≈ükenini 'source' etiketine atƒ±yoruz.
              source: sourceName, // Kaynak Adƒ±

              feedId: feedId, // Filtreleme i√ßin ID
              time: _formatTimeAgo(timestamp),
              unread: !isRead, // OKUNDU DURUMU
              category: categoryName,
              url: itemUrl,
              timestamp: timestamp,
            ),
          );
        }
        return feedItems;
      } else {
        throw Exception(
            '‚ùå Feed √∂ƒüeleri alƒ±namadƒ±: GRAPI sunucu durumu kodu: ${response.statusCode}');
      }
    } on DioException catch (e) {
      throw Exception('‚ö†Ô∏è Dio Hatasƒ± olu≈ütu (Feed √ñƒüeleri): ${e.message}');
    } catch (e) {
      throw Exception('‚ö†Ô∏è Beklenmeyen hata (Feed √ñƒüeleri): $e');
    }
  }

  // Eksik Dio Helper'ƒ± Ekle
  void _setupDioInterceptors() {
    _httpClient.interceptors.add(
      InterceptorsWrapper(
        onError: (DioException e, ErrorInterceptorHandler handler) async {
          if (e.response?.statusCode == 401 &&
              !e.requestOptions.path.contains('/accounts/ClientLogin')) {
            print(
                'üö® 401 Yetkisiz hata alƒ±ndƒ±. Token yenilemeye √ßalƒ±≈üƒ±lƒ±yor...');

            // Kaydedilmi≈ü kimlik bilgilerini _storageService √ºzerinden al
            final credentials =
                await _storageService.getCredentials(); // <<< Burayƒ± deƒüi≈ütirin

            final String? storedUsername = credentials['username'];
            final String? storedPassword = credentials['password'];
            final String? storedApiUrl = credentials['url'];

            if (storedUsername != null &&
                storedPassword != null &&
                storedApiUrl != null) {
              try {
                final newToken = await getNewToken(
                    storedApiUrl, storedUsername, storedPassword);
                print('‚úÖ Yeni token ba≈üarƒ±yla alƒ±ndƒ±.');

                // Yeni token'ƒ± _storageService √ºzerinden g√ºncelle
                // (saveCredentials, url, username ve password'u da tekrar kaydeder, bu uygun)
                await _storageService.saveCredentials(
                  url: storedApiUrl, // Mevcut URL'yi tekrar kaydet
                  username:
                      storedUsername, // Mevcut kullanƒ±cƒ± adƒ±nƒ± tekrar kaydet
                  authToken: newToken, // Yeni token'ƒ± kaydet
                );

                e.requestOptions.headers['Authorization'] =
                    'GoogleLogin auth=$newToken';
                print(
                    'üîÑ Orijinal istek yeni token ile tekrar g√∂nderiliyor...');
                return handler
                    .resolve(await _httpClient.fetch(e.requestOptions));
              } catch (refreshError) {
                print('‚ùå Token yenileme ba≈üarƒ±sƒ±z oldu: $refreshError');
                return handler.next(e);
              }
            } else {
              print(
                  '‚ö†Ô∏è Saklanmƒ±≈ü kimlik bilgileri bulunamadƒ±. Kullanƒ±cƒ± yeniden giri≈ü yapmalƒ±.');
              return handler.next(e);
            }
          }
          return handler.next(e);
        },
      ),
    );
  }

  // YENƒ∞ METOT: Makalenin okundu/okunmadƒ± durumunu sunucuda g√ºnceller

  Future<String> _getActionToken(String apiUrl, String token) async {
    // √ñnce token'ƒ± debug et
    _debugToken(token);

    final normalizedUrl = _normalizeUrl(apiUrl);
    final tokenEndpointUrl =
        '$normalizedUrl/p/api/greader.php/reader/api/0/token';

    // Token'ƒ± temizle - sadece token kƒ±smƒ±nƒ± al
    final cleanToken = token.contains('/') ? token.split('/').last : token;

    print('üîë Action Token ƒ∞steƒüi:');
    print('  URL: $tokenEndpointUrl');
    print('  Clean Token: $cleanToken');

    try {
      final response = await _httpClient.get(
        tokenEndpointUrl,
        options: Options(
          headers: {'Authorization': 'GoogleLogin auth=$cleanToken'},
          validateStatus: (status) => status != null && status < 500,
        ),
      );

      print('üîë Token Yanƒ±tƒ±:');
      print('  Status: ${response.statusCode}');
      print('  Data: ${response.data}');
      print('  Headers: ${response.headers}');

      if (response.statusCode == 200) {
        final String actionToken = response.data.toString().trim();
        if (actionToken.isNotEmpty) {
          print('‚úÖ Action Token ba≈üarƒ±yla alƒ±ndƒ±: $actionToken');
          return actionToken;
        } else {
          throw Exception('Action token bo≈ü d√∂nd√º');
        }
      } else if (response.statusCode == 401) {
        throw Exception('Ana token ge√ßersiz veya s√ºresi dolmu≈ü');
      } else {
        throw Exception('Token alƒ±namadƒ±. Status: ${response.statusCode}');
      }
    } on DioException catch (e) {
      print('‚ùå Token Alma Hatasƒ±: ${e.message}');
      if (e.response != null) {
        print('‚ùå Detay: ${e.response?.statusCode} - ${e.response?.data}');
      }
      throw Exception('Action token alƒ±namadƒ±: ${e.message}');
    }
  }

  @override
  Future<void> markAllAsRead(String apiUrl, String token) async {
    final endpointUrl =
        '$apiUrl/p/api/greader.php/reader/api/0/mark-all-as-read';
    final actionToken =
        await _getActionToken(apiUrl, token); // Action Token √ßekilir

    try {
      final response = await _httpClient.post(
        endpointUrl,
        data: {
          'T': actionToken,
          's': 'user/-/state/com.google/reading-list', // T√ºm akƒ±≈üƒ± i≈üaretle
          'ts': (DateTime.now().millisecondsSinceEpoch * 1000)
              .toString(), // Zaman damgasƒ±
        },
        options: Options(
          contentType: Headers.formUrlEncodedContentType,
          headers: {'Authorization': 'GoogleLogin auth=$token'},
        ),
      );

      if (response.statusCode == 200 &&
          response.data.toString().trim() == 'OK') {
        print('‚úÖ T√úM FEEDLER GRAPI √úZERƒ∞NDEN OKUNDU OLARAK ƒ∞≈ûARETLENDƒ∞.');
        return;
      }
      throw Exception('Toplu okundu i≈üareti ba≈üarƒ±sƒ±z: Yanƒ±t beklenmedik.');
    } on DioException {
      throw Exception('Toplu okundu i≈üaretleme hatasƒ±.');
    }
  }

@override
Future<void> markItemStatus(String apiUrl, String token, String itemId, bool isRead) async {
    // 1. Action Token'ƒ± √ßek (Her zaman gerekli)
    final String actionToken;
    try {
        actionToken = await _getActionToken(apiUrl, token);
    } catch (e) {
        throw Exception('Action Token Alƒ±namadƒ±: Durum g√ºncelleme iptal edildi. Detay: ${e.toString()}');
    }

    // 2. Aksiyon Deƒüi≈ükenleri
    final endpointUrl = '$apiUrl/p/api/greader.php/reader/api/0/edit-tag'; 
    final String actionType = isRead ? 'a' : 'r'; 
    final String tag = 'user/-/state/com.google/read';
    final String itemIdTag = 'tag:google.com,2005:reader/item/${itemId}'; // Item ID String olarak

    try {
        final response = await _httpClient.post(
            endpointUrl,
            data: {
                // T parametresine Action Token'ƒ± g√∂nderiyoruz
                'T': actionToken,        
                'i': itemIdTag,          // Makale ID'si
                'ac': actionType,       
                's': tag,               
            },
            options: Options(
                // KRƒ∞Tƒ∞K: GRAPI POST isteklerinde Content-Type zorunludur.
                contentType: Headers.formUrlEncodedContentType,
                // Yetkilendirme Header'ƒ±
                headers: {'Authorization': 'GoogleLogin auth=$token'}, 
            ),
        );

        if (response.statusCode == 200 && response.data.toString().trim() == 'OK') {
            return; // BA≈ûARI!
        }
        
        // Sunucudan 200 OK geldi ama body 'OK' deƒüilse hata fƒ±rlat.
        throw Exception('Durum g√ºncelleme ba≈üarƒ±sƒ±z: Sunucu yanƒ±tƒ± beklenmedik (${response.data}).');

    } on DioException catch (e) {
        // Hata: 401 Unauthorized (GRAPI'de kalma kararƒ±)
        final statusCode = e.response?.statusCode ?? 0;
        if (statusCode == 401) {
            throw Exception('Sunucu durumu g√ºncelleyemedi: 401 Yetkisiz. Action Token kontrol√º ba≈üarƒ±sƒ±z.');
        }
        throw Exception('Sunucu durumu g√ºncelleyemedi (GRAPI Dio Hatasƒ±: ${e.message})');
    } catch (e) {
        throw Exception('Sunucu g√ºncelleme hatasƒ±: $e');
    }
}
  // Token'ƒ± debug etmek i√ßin yardƒ±mcƒ± metod
  void _debugToken(String token) {
    print('üîê TOKEN ANALƒ∞Zƒ∞:');
    print('  Orijinal Token: $token');
    print('  Uzunluk: ${token.length}');

    if (token.contains('/')) {
      final parts = token.split('/');
      print('  Kullanƒ±cƒ± Adƒ±: ${parts[0]}');
      print('  Token Kƒ±smƒ±: ${parts[1]}');
      print('  Token Uzunluƒüu: ${parts[1].length}');
    }

    // Ge√ßerli bir token genellikle 40 karakter uzunluƒüunda olmalƒ±
    final cleanToken = token.contains('/') ? token.split('/').last : token;
    if (cleanToken.length != 40) {
      print(
          '  ‚ö†Ô∏è  UYARI: Token uzunluƒüu beklenenden farklƒ± (${cleanToken.length} karakter)');
    }
  }

// RssFeedApiDataSource sƒ±nƒ±fƒ±na bu metodu ekleyin:
  @override // getNewToken'ƒ± RssFeedDataSource i√ßine eklediyseniz, @override kullanƒ±n
  Future<String> getNewToken(
      String apiUrl, String username, String password) async {
    final normalizedUrl = _normalizeUrl(apiUrl);
    final authEndpointUrl =
        '$normalizedUrl/p/api/greader.php/accounts/ClientLogin';

    print('üîÑ YENƒ∞ TOKEN ALINIYOR:');
    print('  URL: $authEndpointUrl');
    print('  Kullanƒ±cƒ±: $username');

    try {
      final response = await _httpClient.post(
        authEndpointUrl,
        data: {
          'Email': username,
          'Passwd': password,
          'client': 'FlutterRSSReader',
          'accountType': 'HOSTED_OR_GOOGLE',
          'service': 'reader',
          'output': 'json',
        },
        options: Options(
          contentType: Headers.formUrlEncodedContentType,
          validateStatus: (status) => status != null && status < 500,
        ),
      );

      print('üîë Token Alma Yanƒ±tƒ±:');
      print('  Status: ${response.statusCode}');
      print('  Data: ${response.data}');

      if (response.statusCode == 200) {
        final responseText = response.data.toString();
        print('  Raw Response: $responseText');

        final lines = responseText.split('\n');
        String? authToken;

        for (final line in lines) {
          if (line.startsWith('Auth=')) {
            authToken = line.substring(5).trim();
            break;
          }
        }

        if (authToken != null && authToken.isNotEmpty) {
          print('‚úÖ YENƒ∞ TOKEN BA≈ûARIYLA ALINDI: $authToken');
          print('‚úÖ Token Uzunluƒüu: ${authToken.length}');
          // Yeni tokenƒ± SecureStorageService √ºzerinden kaydet
          await _storageService.saveCredentials(
              url: _normalizeUrl(apiUrl), // Mevcut API URL'sini tekrar kaydet
              username: username,
              authToken: authToken); // <<< Burayƒ± deƒüi≈ütirin
          return authToken;
        } else {
          throw Exception(
              'Token response i√ßinde bulunamadƒ±. Response: $responseText');
        }
      } else if (response.statusCode == 403) {
        throw Exception(
            'Eri≈üim reddedildi. Kullanƒ±cƒ± adƒ±/≈üifre hatalƒ± veya hesap kƒ±sƒ±tlamasƒ± var.');
      } else if (response.statusCode == 401) {
        throw Exception(
            'Kimlik doƒürulama ba≈üarƒ±sƒ±z. Kullanƒ±cƒ± adƒ±/≈üifre hatalƒ±.');
      } else {
        throw Exception(
            'Authentication failed: ${response.statusCode} - ${response.data}');
      }
    } on DioException catch (e) {
      print('‚ùå Token Alma Hatasƒ±: ${e.message}');
      if (e.response != null) {
        print('‚ùå Detay: ${e.response?.statusCode} - ${e.response?.data}');
      }
      throw Exception('Authentication error: ${e.message}');
    }
  }

  Future<void> testCurrentToken(String apiUrl, String currentToken) async {
    print('üß™ MEVCUT TOKEN TESTƒ∞ BA≈ûLADI');
    final normalizedUrl = _normalizeUrl(apiUrl);
    final testEndpointUrl =
        '$normalizedUrl/p/api/greader.php/reader/api/0/user-info';

    // Token‚Äôƒ± temizle (bazƒ± durumlarda username/token formatƒ±nda geliyor)
    final cleanToken = currentToken.contains('/')
        ? currentToken.split('/').last
        : currentToken;

    try {
      final response = await _httpClient.get(
        testEndpointUrl,
        options: Options(
          headers: {'Authorization': 'GoogleLogin auth=$cleanToken'},
          validateStatus: (status) => status != null && status < 500,
        ),
      );

      print('üîç Token Test Yanƒ±tƒ±:');
      print('  Status: ${response.statusCode}');
      print('  Data: ${response.data}');

      if (response.statusCode == 200) {
        print('‚úÖ Token ge√ßerli. Kullanƒ±cƒ± bilgileri alƒ±ndƒ±.');
      } else if (response.statusCode == 401) {
        print('‚ùå Token ge√ßersiz veya s√ºresi dolmu≈ü.');
      } else {
        print('‚ö†Ô∏è Beklenmedik yanƒ±t: ${response.statusCode}');
      }
    } on DioException catch (e) {
      print('‚ùå Token Testi Hatasƒ±: ${e.message}');
      if (e.response != null) {
        print('‚ùå Detay: ${e.response?.statusCode} - ${e.response?.data}');
      }
    } catch (e) {
      print('‚ö†Ô∏è Beklenmeyen hata (Token Test): $e');
    }
  }
}

// firstWhereOrNull uzantƒ±sƒ±nƒ± sim√ºle edelim (eƒüer projenizde yoksa)
extension on List<RssCategory> {
  RssCategory? firstWhereOrNull(bool Function(RssCategory) test) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }
}
